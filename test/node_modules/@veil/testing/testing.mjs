/*
 * Copyright (c) 2022 Light Source Software, LLC. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

import assert from 'node:assert'
import { tmpdir } from 'node:os'
import { join } from 'node:path'
import { symlinkSync, unlinkSync } from 'node:fs'

const tmp = tmpdir()

// contents of testLink (tmp/test.link)
export const testLinkDestination = process.platform === 'win32' ? '.\\path\\to\\something' : './path/to/something'

// TODO: move to node:assert
export const rejects = async (promise) => {
  try {
    await promise
  } catch {
    return
  }

  assert.fail('exception expected')
}

// promisify fs functions
export const fsAsyncWrap = async (func, ...args) => {
  return await new Promise((resolve, reject) => {
    func(...args, (err, data) => {
      if (err) {
        reject(err)
      } else {
        resolve(data)
      }
    })
  })
}

// check that Stats are for a file
export const checkStatsForFile = (stats, expectedType = 'number') => {
  assert(stats)
  assert.equal(typeof stats.mode, expectedType)
  assert.equal(stats.isFile(), true)
  assert.equal(stats.isDirectory(), false)
  assert.equal(stats.isBlockDevice(), false)
  assert.equal(stats.isFIFO(), false)
  assert.equal(stats.isCharacterDevice(), false)
  assert.equal(stats.isSocket(), false)
  assert.equal(stats.isSymbolicLink(), false)
}

// check that Stats are for a directory
export const checkStatsForDirectory = (stats, expectedType = 'number') => {
  assert(stats)
  assert.equal(typeof stats.mode, expectedType)
  assert.equal(stats.isFile(), false)
  assert.equal(stats.isDirectory(), true)
  assert.equal(stats.isBlockDevice(), false)
  assert.equal(stats.isFIFO(), false)
  assert.equal(stats.isCharacterDevice(), false)
  assert.equal(stats.isSocket(), false)
  assert.equal(stats.isSymbolicLink(), false)
}

// check that Stats are for a link
export const checkStatsForSymbolicLink = (stats, expectedType = 'number') => {
  assert(stats)
  assert.equal(typeof stats.mode, expectedType)
  assert.equal(stats.isFile(), false)
  assert.equal(stats.isDirectory(), false)
  assert.equal(stats.isBlockDevice(), false)
  assert.equal(stats.isFIFO(), false)
  assert.equal(stats.isCharacterDevice(), false)
  assert.equal(stats.isSocket(), false)
  assert.equal(stats.isSymbolicLink(), true)
}

// returns the path for test.link. the directory containing test.link exists, but test.link does not
export const emptyTestLink = () => {
  const p = join(tmp, 'test.link')

  try {
    unlinkSync(p)
  } catch {

  }

  return p
}

// returns the path for test.link. ensures that the file exists and the destination is testLinkDestination
export const ensureTestLink = () => {
  const p = emptyTestLink()

  symlinkSync(testLinkDestination, p)

  return p
}

// on exit, delete test.link
process.on('exit', () => emptyTestLink())
